package main

import (
	"fmt"
	"go/types"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	. "github.com/dave/jennifer/jen"
	"golang.org/x/tools/go/packages"
)

/*type generatorData struct {
	sourceStruct     interface{}
	targetStruct     interface{}
	sourceStructType string
	targetStructType string
}*/

func main() {
	//var data generatorData
	//flag.StringVar(&data.sourceStructType, "source", "", "The source struct type to be generated for mapperx")
	//flag.StringVar(&data.targetStructType, "target", "", "The target struct type to be generated for mappex")
	//flag.Parse()

	// TODO we should have source and target type then validate those
	if len(os.Args) != 3 {
		exitWithError(fmt.Errorf("expected exactly two arguments: <source type> <target type>"))
	}
	sourceType := os.Args[1]
	sourceTypePackage, sourceTypeName := splitSourceType(sourceType)

	targetType := os.Args[2]
	targetTypePackage, targetTypeName := splitSourceType(targetType)

	sourceStructType := checkTypeEligibility(sourceTypePackage, sourceTypeName)
	targetStructType := checkTypeEligibility(targetTypePackage, targetTypeName)

	// Generate code using jennifer
	err := generateMapperx(sourceTypeName, sourceStructType, targetTypeName, targetStructType)
	if err != nil {
		exitWithError(err)
	}

	sampleGenerate()
}

// Use a simple regexp pattern to match tag values
var structColPattern = regexp.MustCompile(`mapperx:"([^"]+)"`)

func sampleGenerate() {
	f := NewFile("mapperx")
	f.Func().Id("main").Params().Block(
		Qual("fmt", "Println").Call(Lit("Hello, world")),
	)
	fmt.Printf("%#v", f)
}

// TODO structure code gen logic, maybe seperate it into another file
func generateMapperx(sourceTypeName string, sourceStructType *types.Struct, targetTypeName string, targetStructType *types.Struct) error {
	f := NewFile("mapperx")
	f.PackageComment("Code generated by mapperx, PLEASE DO NOT EDIT.")

	var (
		changeSetFields []Code
	)

	// Iterate over struct fields
	for i := 0; i < sourceStructType.NumFields(); i++ {
		field := sourceStructType.Field(i)

		// Generate code for each changeset field
		code := Id(field.Name())
		switch v := field.Type().(type) {
		case *types.Basic:
			code.Op("*").Id(v.String())
		case *types.Named:
			typeName := v.Obj()
			// Qual automatically imports packages
			code.Op("*").Qual(
				typeName.Pkg().Path(),
				typeName.Name(),
			)
		default:
			return fmt.Errorf("struct field type not hanled: %T", v)
		}
		changeSetFields = append(changeSetFields, code)
	}

	// Generate changeset type
	changeSetName := sourceTypeName + "ChangeSet"
	f.Type().Id(changeSetName).Struct(changeSetFields...)

	// 1. Collect code in toMap() block
	var toMapBlock []Code

	// 2. Build "m := make(map[string]interface{})"
	toMapBlock = append(toMapBlock, Id("m").Op(":=").Make(Map(String()).Interface()))

	for i := 0; i < sourceStructType.NumFields(); i++ {
		field := sourceStructType.Field(i)
		tagValue := sourceStructType.Tag(i)

		matches := structColPattern.FindStringSubmatch(tagValue)
		if matches == nil {
			continue
		}
		col := matches[1]

		// 3. Build "if c.Field != nil { m["col"] = *c.Field }"
		code := If(Id("c").Dot(field.Name()).Op("!=").Nil()).Block(
			Id("m").Index(Lit(col)).Op("=").Op("*").Id("c").Dot(field.Name()),
		)
		toMapBlock = append(toMapBlock, code)
	}

	// 4. Build return statement
	toMapBlock = append(toMapBlock, Return(Id("m")))

	// 5. Build toMap method
	f.Func().Params(
		Id("c").Id(changeSetName),
	).Id("toMap").Params().Map(String()).Interface().Block(
		toMapBlock...,
	)

	// Build the target file name
	goFile := os.Getenv("GOFILE")
	ext := filepath.Ext(goFile)
	baseFilename := goFile[0 : len(goFile)-len(ext)]
	targetFilename := baseFilename + "_" + strings.ToLower(sourceTypeName) + "_gen.go"

	// Write generated file
	return f.Save(targetFilename)
}

func checkTypeEligibility(typePackage string, typeName string) *types.Struct {
	// Inspect package and use type checker to infer imported types
	pkg := loadPackage(typePackage)

	// Lookup the given source type name in the package declarations
	obj := pkg.Types.Scope().Lookup(typeName)
	if obj == nil {
		exitWithError(fmt.Errorf("%s not found in declared types of %s", typeName, pkg))
	}

	// We check if it is a declared type
	if _, ok := obj.(*types.TypeName); !ok {
		exitWithError(fmt.Errorf("%v is not a named type", obj))
	}
	// We expect the underlying type to be a struct
	structType, ok := obj.Type().Underlying().(*types.Struct)
	if !ok {
		exitWithError(fmt.Errorf("type %v is not a struct", obj))
	}
	return structType
}

func loadPackage(path string) *packages.Package {
	cfg := &packages.Config{Mode: packages.NeedTypes | packages.NeedImports}
	pkgs, err := packages.Load(cfg, path)
	if err != nil {
		exitWithError(fmt.Errorf("loading packages for inspection: %v", err))
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}

	return pkgs[0]
}

func splitSourceType(sourceType string) (string, string) {
	index := strings.LastIndexByte(sourceType, '.')
	if index == -1 {
		exitWithError(fmt.Errorf(`expected qualified type as "filepath/filename.MyType"`))
	}
	sourceTypePackage := sourceType[0:index]
	sourceTypeName := sourceType[index+1:]
	return sourceTypePackage, sourceTypeName
}

func exitWithError(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}
