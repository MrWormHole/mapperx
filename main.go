package main

import (
	"flag"
	"fmt"
	"go/types"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"
	"unicode"

	. "github.com/dave/jennifer/jen"
	"golang.org/x/tools/go/packages"
)

var outputFilename string
var outputDirectory string

func main() {
	var source string
	var target string
	flag.StringVar(&outputFilename, "filename", "",
		"The filename for mapperx generated code, ex: MapAdminToUser or AdminToUser")
	flag.StringVar(&outputDirectory, "directory", ".",
		"The relative output directory for mapperx generated code, ex: ../mapperx or ./mapperx")
	flag.StringVar(&source, "source", "",
		"Source that is specified, ex filepath/filename.MyType")
	flag.StringVar(&target, "target", "",
		"Target that is specified, ex: filepath/filename.YourType")
	flag.Parse()

	if strings.TrimSpace(source) == "" {
		exitWithError(fmt.Errorf("source is not specified"))
	}
	if strings.TrimSpace(target) == "" {
		exitWithError(fmt.Errorf("target is not specified"))
	}

	sourceTypePackage, sourceTypeName := getFilepathAndStructTypeName(source)
	targetTypePackage, targetTypeName := getFilepathAndStructTypeName(target)

	sourceStructType, err := checkTypeEligibility(sourceTypePackage, sourceTypeName)
	if err != nil {
		exitWithError(err)
	}

	targetStructType, err := checkTypeEligibility(targetTypePackage, targetTypeName)
	if err != nil {
		exitWithError(err)
	}

	sourceInfo := NewInfo(sourceTypeName, sourceTypePackage, sourceStructType)
	targetInfo := NewInfo(targetTypeName, targetTypePackage, targetStructType)

	err = generate(sourceInfo, targetInfo)
	if err != nil {
		exitWithError(err)
	}
}

func camelCase(s string) string {
	f := strings.ToLower(string(s[0]))
	return f + s[1:]
}

func generate(s, t *info) error {
	f := NewFile("mapperx")
	comment := fmt.Sprintf("Code generated by mapperx, PLEASE DO NOT EVER EDIT. GENERATATED AT %s", time.Now().Format(time.RFC3339))
	f.PackageComment(comment)

	// Use a simple regexp pattern to match struct tags
	structTagPattern := regexp.MustCompile(`mapperx:"([^"]+)"`)

	// struct-to-struct type check
	functionName := fmt.Sprintf("%sTo%s", s.typeName, t.typeName)
	if s.typeName == t.typeName || s.structType.String() == t.structType.String() {
		return fmt.Errorf("expected 2 different struct types")
	}

	// form the function signature
	signature := f.Func().Id(functionName).Params(
		Id(camelCase(s.typeName)).Op("*").Qual(s.typePackage, s.typeName),
		Id(camelCase(t.typeName)).Op("*").Qual(t.typePackage, t.typeName),
	)

	tags := make(map[int]string)
	for i := 0; i < s.structType.NumFields(); i++ {
		tag := s.structType.Tag(i)
		matches := structTagPattern.FindStringSubmatch(tag)
		if matches == nil || len(matches) < 2 {
			continue
		}

		var alreadyExists bool
		var existingIndex int
		for k, v := range tags {
			if v == matches[1] {
				alreadyExists = true
				existingIndex = k
			}
		}
		if alreadyExists {
			fmt.Printf("multiple same name tags are being used! "+
				"only first tag inside field %s will be used for mapping\n",
				s.structType.Field(existingIndex).Name())
			continue
		}

		tags[i] = matches[1]
	}

	var mappedFields []Code
	for i := 0; i < s.structType.NumFields(); i++ {
		sourceField := s.structType.Field(i)
		if unicode.IsLower(rune(sourceField.Name()[0])) {
			continue
		}

		for j := 0; j < t.structType.NumFields(); j++ {
			targetField := t.structType.Field(j)
			if unicode.IsLower(rune(targetField.Name()[0])) {
				continue
			}

			if tags[i] == targetField.Name() {
				fmt.Printf("source: %s , target: %s \n", sourceField.Name(), targetField.Name())
				mappedFields = append(mappedFields, constructMappedFields(s, t, sourceField, targetField)...)
				break
			}

			if sourceField.Name() == targetField.Name() {
				fmt.Printf("source: %s , target: %s \n", sourceField.Name(), targetField.Name())
				mappedFields = append(mappedFields, constructMappedFields(s, t, sourceField, targetField)...)
				break
			}
		}
	}

	// form the body
	signature.Block(
		mappedFields...,
	)

	fmt.Printf("%#v", f)

	if strings.TrimSpace(outputFilename) == "" {
		goFile := os.Getenv("GOFILE")
		ext := filepath.Ext(goFile)
		baseFilename := goFile[0 : len(goFile)-len(ext)]
		outputFilename = fmt.Sprintf("%s_%s_gen", baseFilename, strings.ToLower(s.typeName))
	}

	return f.Save(fmt.Sprintf("%s/%s.go", outputDirectory, outputFilename))
}

func constructMappedFields(s, t *info, sourceField, targetField *types.Var) []Code {
	var mappedFields []Code

	switch sourceField.Type().(type) {
	case *types.Basic:
		line := Id(camelCase(t.typeName)).Dot(targetField.Name()).
			Op("=").
			Id(camelCase(s.typeName)).Dot(sourceField.Name())
		mappedFields = append(mappedFields, line)
	case *types.Named:
		// TODO what if a struct is named?
		fmt.Println("named")
		line := Id(camelCase(t.typeName)).Dot(targetField.Name()).
			Op("=").
			Id(camelCase(s.typeName)).Dot(sourceField.Name())
		mappedFields = append(mappedFields, line)
	case *types.Slice:
		// TODO what if slice has structs instead of primitives?
		allocLine := Id(camelCase(t.typeName)).Dot(targetField.Name()).
			Op("=").Make(Id(camelCase(targetField.Type().String())), Len(Id(camelCase(s.typeName)).Dot(sourceField.Name())))
		copyLine := Copy(Id(camelCase(t.typeName)).Dot(targetField.Name()), Id(camelCase(s.typeName)).Dot(sourceField.Name()))
		mappedFields = append(mappedFields, allocLine, copyLine)
	case *types.Array:
		// TODO what if array has structs instead of primitives?
		allocLine := Id(camelCase(t.typeName)).Dot(targetField.Name()).
			Op("=").Make(Id(camelCase(targetField.Type().String())), Len(Id(camelCase(s.typeName)).Dot(sourceField.Name())))
		copyLine := Copy(Id(camelCase(t.typeName)).Dot(targetField.Name()), Id(camelCase(s.typeName)).Dot(sourceField.Name()))
		mappedFields = append(mappedFields, allocLine, copyLine)
	case *types.Map:
		allocLine := Id(camelCase(t.typeName)).Dot(targetField.Name()).
			Op("=").Make(Id(camelCase(targetField.Type().String())), Len(Id(camelCase(s.typeName)).Dot(sourceField.Name())))
		copyLine := For(Id("k").Op(",").Id("v").Op(":=").
			Range().Id(camelCase(s.typeName)).Dot(sourceField.Name())).
			Block(Id(camelCase(t.typeName)).Dot(targetField.Name()).Index(Id("k")).Op("=").Id("v"))
		mappedFields = append(mappedFields, allocLine, copyLine)
	case *types.Pointer:
		line := Id(camelCase(t.typeName)).Dot(targetField.Name()).
			Op("=").
			Id(camelCase(s.typeName)).Dot(sourceField.Name())
		mappedFields = append(mappedFields, line)
	default:
		fmt.Printf("%v type is not supported, so it is ignored for now \n", sourceField.Type())
	}

	return mappedFields
}

func checkTypeEligibility(typePackage string, typeName string) (*types.Struct, error) {
	// Inspect package and use type checker to infer imported types
	pkg := loadPackage(typePackage)
	if pkg == nil {
		return nil, fmt.Errorf("package %s not found", typePackage)
	}

	// Lookup the given source type name in the package declarations
	obj := pkg.Types.Scope().Lookup(typeName)
	if obj == nil {
		return nil, fmt.Errorf("%s not found in declared types of %s", typeName, pkg)
	}

	// We check if it is a declared type
	if _, ok := obj.(*types.TypeName); !ok {
		return nil, fmt.Errorf("%v is not a named type", obj)
	}

	// We expect the underlying type to be a struct
	structType, ok := obj.Type().Underlying().(*types.Struct)
	if !ok {
		return nil, fmt.Errorf("type %v is not a struct", obj)
	}
	return structType, nil
}

func loadPackage(path string) *packages.Package {
	cfg := &packages.Config{Mode: packages.NeedTypes | packages.NeedImports}
	pkgs, err := packages.Load(cfg, path)
	if err != nil {
		exitWithError(fmt.Errorf("loading packages for inspection: %v", err))
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}

	if len(pkgs) == 0 {
		return nil
	}
	return pkgs[0]
}

func getFilepathAndStructTypeName(definition string) (string, string) {
	index := strings.LastIndexByte(definition, '.')
	if index == -1 {
		exitWithError(fmt.Errorf(`expected qualified definition as "filepath/filename.MyType"`))
	}
	filepath := definition[0:index]
	structTypeName := definition[index+1:]
	return filepath, structTypeName
}

func exitWithError(err error) {
	if err != nil {
		_, _ = fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}
