package main

import (
	"flag"
	"fmt"
	"go/types"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	. "github.com/dave/jennifer/jen"
	"golang.org/x/tools/go/packages"
)

func main() {
	var directory string
	var source string
	var target string
	flag.StringVar(&directory,"output", "", "The relative output directory for mapperx generated code")
	flag.StringVar(&source, "source", "", "Source that is specified, ex filepath/filename.MyType")
	flag.StringVar(&target, "target", "", "Target that is specified, ex: filepath/filename.YourType")
	flag.Parse()
	if directory == "" {
		exitWithError(fmt.Errorf("output directory is not specified, ex: ../mapperx or ./mapperx"))
	}
	if source == "" {
		exitWithError(fmt.Errorf("source is not specified"))
	}
	if target == "" {
		exitWithError(fmt.Errorf("target is not specified"))
	}

	sourceTypePackage, sourceTypeName := getFilepathAndStructTypeName(source)
	targetTypePackage, targetTypeName := getFilepathAndStructTypeName(target)

	sourceStructType, err := checkTypeEligibility(sourceTypePackage, sourceTypeName)
	if err != nil {
		exitWithError(err)
	}

	targetStructType, err := checkTypeEligibility(targetTypePackage, targetTypeName)
	if err != nil {
		exitWithError(err)
	}

	sourceInfo := NewInfo(sourceTypeName, sourceTypePackage, sourceStructType)
	targetInfo := NewInfo(targetTypeName, targetTypePackage, targetStructType)

	err = generate(sourceInfo, targetInfo, directory)
	if err != nil {
		exitWithError(err)
	}
}

func camelCase(s string) string {
	f := strings.ToLower(string(s[0]))
	return f + s[1:]
}

func generate(s *info, t *info, dir string) error {
	f := NewFile("mapperx")
	comment := fmt.Sprintf("Code generated by mapperx, PLEASE DO NOT EVER EDIT. GENERATATED AT %s", time.Now())
	f.PackageComment(comment)

	// Use a simple regexp pattern to match struct tags
	structTagPattern := regexp.MustCompile(`mapperx:"([^"]+)"`)

	// struct-to-struct type check
	functionName := fmt.Sprintf("Map%sTo%s", s.typeName, t.typeName)
	if s.typeName == t.typeName || s.structType.String() == t.structType.String() {
		return fmt.Errorf("expected 2 different struct types")
	}

	// form the function signature
	signature := f.Func().Id(functionName).Params(
		Id(camelCase(s.typeName)).Op("*").Qual(s.typePackage, s.typeName),
		Id(camelCase(t.typeName)).Op("*").Qual(t.typePackage, t.typeName),
	)

	tags := make(map[int]string)
	for i := 0; i < s.structType.NumFields(); i++ {
		tag := s.structType.Tag(i)
		matches := structTagPattern.FindStringSubmatch(tag)
		if matches == nil || len(matches) < 2 {
			continue
		}

		var	alreadyExists bool
		var existingIndex int
		for k, v := range tags {
			if v == matches[1] {
				alreadyExists = true
				existingIndex = k
			}
		}
		if alreadyExists {
			fmt.Printf("multiple same name tags are being used! " +
				"only first tag inside field %s will be used for mapping\n",
				s.structType.Field(existingIndex).Name())
			continue
		}


		tags[i] = matches[1]
	}

	var mappedFields []Code
	for i := 0; i < s.structType.NumFields(); i++ {
		sourceField := s.structType.Field(i)
		for j := 0; j < t.structType.NumFields(); j++ {
			targetField := t.structType.Field(j)
			tag := tags[i]
			if tag == targetField.Name() {
				fmt.Printf("source: %s , target: %s \n", sourceField.Name(), targetField.Name())

				switch sourceField.Type().(type) {
				case *types.Basic:
					line := Id(camelCase(t.typeName)).Dot(targetField.Name()).
						Op("=").
						Id(camelCase(s.typeName)).Dot(sourceField.Name())
					mappedFields = append(mappedFields, line)
				case *types.Named:
					// TODO what if a struct is named?
					line := Id(camelCase(t.typeName)).Dot(targetField.Name()).
						Op("=").
						Id(camelCase(s.typeName)).Dot(sourceField.Name())
					mappedFields = append(mappedFields, line)
				case *types.Slice:
					// TODO what if slice has structs instead of primitives?
					allocLine := Id(camelCase(t.typeName)).Dot(targetField.Name()).
						Op("=").Make(Id(camelCase(targetField.Type().String())),Len(Id(camelCase(s.typeName)).Dot(sourceField.Name())))
					copyLine := Copy(Id(camelCase(t.typeName)).Dot(targetField.Name()), Id(camelCase(s.typeName)).Dot(sourceField.Name()))
					mappedFields = append(mappedFields, allocLine, copyLine)
				case *types.Array:
					// TODO what if array has structs instead of primitives?
					allocLine := Id(camelCase(t.typeName)).Dot(targetField.Name()).
						Op("=").Make(Id(camelCase(targetField.Type().String())),Len(Id(camelCase(s.typeName)).Dot(sourceField.Name())))
					copyLine := Copy(Id(camelCase(t.typeName)).Dot(targetField.Name()), Id(camelCase(s.typeName)).Dot(sourceField.Name()))
					mappedFields = append(mappedFields, allocLine, copyLine)
				//case *types.Map:
				//case *types.Struct:
				default:
					fmt.Printf("%v type is not supported, so it is ignored for now \n", sourceField.Type())
				}

				break
			}

			if sourceField.Name() == targetField.Name() {
				fmt.Printf("source: %s , target: %s \n", sourceField.Name(), targetField.Name())

				switch sourceField.Type().(type) {
				case *types.Basic:
					line := Id(camelCase(t.typeName)).Dot(targetField.Name()).
						Op("=").
						Id(camelCase(s.typeName)).Dot(sourceField.Name())
					mappedFields = append(mappedFields, line)
				case *types.Named:
					// TODO what if a struct is named?
					line := Id(camelCase(t.typeName)).Dot(targetField.Name()).
						Op("=").
						Id(camelCase(s.typeName)).Dot(sourceField.Name())
					mappedFields = append(mappedFields, line)
				case *types.Slice:
					// TODO what if slice has structs instead of primitives?
					allocLine := Id(camelCase(t.typeName)).Dot(targetField.Name()).
						Op("=").Make(Id(camelCase(targetField.Type().String())),Len(Id(camelCase(s.typeName)).Dot(sourceField.Name())))
					copyLine := Copy(Id(camelCase(t.typeName)).Dot(targetField.Name()), Id(camelCase(s.typeName)).Dot(sourceField.Name()))
					mappedFields = append(mappedFields, allocLine, copyLine)
				case *types.Array:
					// TODO what if array has structs instead of primitives?
					allocLine := Id(camelCase(t.typeName)).Dot(targetField.Name()).
						Op("=").Make(Id(camelCase(targetField.Type().String())),Len(Id(camelCase(s.typeName)).Dot(sourceField.Name())))
					copyLine := Copy(Id(camelCase(t.typeName)).Dot(targetField.Name()), Id(camelCase(s.typeName)).Dot(sourceField.Name()))
					mappedFields = append(mappedFields, allocLine, copyLine)
				//case *types.Map:
				//case *types.Struct:
				default:
					fmt.Printf("%v type is not supported, so it is ignored for now \n", sourceField.Type())
				}

				break
			}
		}
	}

	// form the body
	signature.Block(
		mappedFields...,
	)

	//TODO: if no filename is specified, then generate filename with default directory, make filename optional instead of hardcoded
	goFile := os.Getenv("GOFILE")
	ext := filepath.Ext(goFile)
	baseFilename := goFile[0 : len(goFile)-len(ext)]
	savedFilename := fmt.Sprintf("%s_%s_gen.go", baseFilename, strings.ToLower(s.typeName))

	fmt.Printf("%#v", f)
	return f.Save(fmt.Sprintf("%s/%s", dir, savedFilename))
}

func checkTypeEligibility(typePackage string, typeName string) (*types.Struct, error) {
	// Inspect package and use type checker to infer imported types
	pkg := loadPackage(typePackage)

	// Lookup the given source type name in the package declarations
	obj := pkg.Types.Scope().Lookup(typeName)
	if obj == nil {
		return nil, fmt.Errorf("%s not found in declared types of %s", typeName, pkg)
	}

	// We check if it is a declared type
	if _, ok := obj.(*types.TypeName); !ok {
		return nil, fmt.Errorf("%v is not a named type", obj)
	}

	// We expect the underlying type to be a struct
	structType, ok := obj.Type().Underlying().(*types.Struct)
	if !ok {
		return nil, fmt.Errorf("type %v is not a struct", obj)
	}
	return structType, nil
}

func loadPackage(path string) *packages.Package {
	cfg := &packages.Config{Mode: packages.NeedTypes | packages.NeedImports}
	pkgs, err := packages.Load(cfg, path)
	if err != nil {
		exitWithError(fmt.Errorf("loading packages for inspection: %v", err))
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}

	return pkgs[0]
}

func getFilepathAndStructTypeName(definition string) (string, string) {
	index := strings.LastIndexByte(definition, '.')
	if index == -1 {
		exitWithError(fmt.Errorf(`expected qualified definition as "filepath/filename.MyType"`))
	}
	filepath := definition[0:index]
	structTypeName := definition[index+1:]
	return filepath, structTypeName
}

func exitWithError(err error) {
	if err != nil {
		_, _ = fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}
